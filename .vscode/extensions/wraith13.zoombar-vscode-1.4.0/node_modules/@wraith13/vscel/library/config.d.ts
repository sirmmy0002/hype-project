import { Cache } from "./cache";
declare type PropertiesBaseType = {
    [key: string]: {
        default?: any;
        minimum?: any;
        maximum?: any;
    };
};
interface PackageJson<PropertiesT extends PropertiesBaseType> {
    contributes: PackageJsonContributes<PropertiesT>;
}
interface PackageJsonContributes<PropertiesT extends PropertiesBaseType> {
    configuration: PackageJsonConfiguration<PropertiesT>[];
}
interface PackageJsonConfiguration<PropertiesT extends PropertiesBaseType> {
    properties: PropertiesT;
}
export interface InspectResultType<valueT> {
    key: string;
    defaultValue?: valueT;
    globalValue?: valueT;
    workspaceValue?: valueT;
    workspaceFolderValue?: valueT;
    defaultLanguageValue?: valueT;
    globalLanguageValue?: valueT;
    workspaceLanguageValue?: valueT;
    workspaceFolderLanguageValue?: valueT;
    languageIds?: string[];
}
export declare class Entry<PropertiesT extends PropertiesBaseType, valueT> {
    properties: PropertiesT;
    key: keyof PropertiesT & string;
    validator?: ((value: valueT) => boolean) | undefined;
    defaultValue: valueT;
    minValue: valueT | undefined;
    maxValue: valueT | undefined;
    constructor(properties: PropertiesT, key: keyof PropertiesT & string, validator?: ((value: valueT) => boolean) | undefined);
    regulate: (rawKey: string, value: valueT) => valueT;
    cache: Cache<string, valueT>;
    inspectCache: Cache<string, InspectResultType<valueT>>;
    get: (key: string) => valueT;
    getCache: (key: string) => valueT;
    inspect: (key: string) => InspectResultType<valueT>;
    getInspectCache: (key: string) => InspectResultType<valueT>;
    clear: () => void;
}
export declare class MapEntry<PropertiesT extends PropertiesBaseType, ObjectT> {
    properties: PropertiesT;
    key: keyof PropertiesT & string;
    mapObject: ObjectT;
    constructor(properties: PropertiesT, key: keyof PropertiesT & string, mapObject: ObjectT);
    config: Entry<PropertiesT, keyof ObjectT>;
    get: (languageId: string) => ObjectT[keyof ObjectT];
    getCache: (languageId: string) => ObjectT[keyof ObjectT];
    inspect: (key: string) => InspectResultType<keyof ObjectT>;
    getInspectCache: (key: string) => InspectResultType<keyof ObjectT>;
    clear: () => void;
}
export declare const makeEnumValidator: <ObjectT>(mapObject: ObjectT) => (value: keyof ObjectT) => boolean;
export declare const stringArrayValidator: (value: string[]) => boolean;
export declare type IEntry<PropertiesT extends PropertiesBaseType, valueT> = Entry<PropertiesT, valueT> | MapEntry<PropertiesT, valueT>;
export declare class Root<PropertiesT extends PropertiesBaseType> {
    properties: PropertiesT;
    constructor(properties: PropertiesT);
    makeEntry: <valueT>(key: keyof PropertiesT & string, validator?: ((value: valueT) => boolean) | undefined) => Entry<PropertiesT, valueT>;
    makeMapEntry: <ObjectT>(key: keyof PropertiesT & string, mapObject: ObjectT) => MapEntry<PropertiesT, ObjectT>;
    entries: IEntry<PropertiesT, unknown>[];
    private register;
}
export declare const makeRoot: <PropertiesT extends PropertiesBaseType>(packageJson: PackageJson<PropertiesT>) => Root<PropertiesT>;
export {};
